#!/usr/bin/env bash

set -efu

function sdebug {
  if [[ -n "${DEBUG:-}" ]]; then
    sdebug "$@" 1>&2
  fi
}

function save-function {
    local original="$(declare -f $1)"
    local override="$2${original#$1}"
    eval "$override"
}

# https://stackoverflow.com/questions/38972736/how-to-print-lines-between-two-patterns-inclusive-or-exclusive-in-sed-awk-or
function sub-help {
  FLAGS_PARENT="${0##*/}"
  FLAGS_PARENT="${FLAGS_PARENT//-/ }"

  FLAGS_HELP="$(awk '
    BEGIN   {first=1}
    /^# /   {if (first) {flag=1; first=0}}
    /^[^#]/ {flag=0}
    {gsub(/^#/, "")}
    {gsub(/^ /, "")}
    flag
  ' "$0")"

  FLAGS_HELP="${FLAGS_HELP:+${FLAGS_HELP}
}"

  if [[ "$FLAGS_HELP" =~ ^\s*$ || ! "$FLAGS_HELP" =~ ^USAGE: ]]; then
    FLAGS_HELP="USAGE: ${FLAGS_PARENT} [flags] args
"
  fi

  shflags-help
  exit $?
}

function call-main {
  if [[ -x /usr/local/opt/gnu-getopt/bin/getopt ]]; then
    export FLAGS_GETOPT_CMD=/usr/local/opt/gnu-getopt/bin/getopt
  fi

  source shflags

  save-function flags_help shflags-help
  function flags_help { sub-help; }

  if declare -F options >/dev/null; then
    options
  fi
   
  FLAGS_HELP="$(date)"

  POSIXLY_CORRECT=1 FLAGS "$@" || return $?
  unset POSIXLY_CORRECT
  eval set -- "${FLAGS_ARGV}"

  sdebug "call: main $@"
  main "$@"
  return $?
}

function sub-main {
  local cmd="$1"; shift
  local bare_cmd="${cmd##*/}" 

  sdebug
  sdebug "cmd: $cmd"
  sdebug "bare-cmd; $bare_cmd"
  sdebug "args: $@"

  if [[ "$#" == 0 ]]; then
    call-main "$@"
    return $?
  fi

  local sub_cmd="$1"

  sdebug "finding: ${bare_cmd}-${sub_cmd}"
  found_cmd="$(type -P "${bare_cmd}-${sub_cmd}" || true)"
  if [[ -z "${found_cmd}" ]]; then
    call-main "$@"
    return $?
  fi

  shift
  sdebug "exec: ${bare_cmd}-${sub_cmd} $@"
  exec "${bare_cmd}-${sub_cmd}" "$@"
  return $?
}

sub-main "$@"
